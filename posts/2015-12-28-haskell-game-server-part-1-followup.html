<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Uncanny Works - Blog</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" href="../css/highlight.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../archive.html">Archive</a>
                <a href="https://twitter.com/uncannyworks">@uncannyworks</a>
                <a href="https://twitter.com/mojobojo">@mojobojo (Brian)</a>
                <a href="https://twitter.com/CrappyGraphiX">@CrappyGraphiX (Chris)</a>
                <a href="https://github.com/uncannyworks">github</a>
            </div>
            <a href="../">
                <div id="logo">
                    <img src="../images/rogo1_kuro.png" />
                </div>
            </a>
        </div>
        <div id="content">
            <h1>Haskell Game Server - Part 1 Followup (Cross Post)</h1>
<div class="info">
    Posted on December 28, 2015
    
</div>

<p>(<em>This is a cross post from <a href="https://twitter.com/mojobojo">Brian’s</a> personal blog</em> - <a href="http://mojobojo.com/posts/2015-12-28-haskell-game-server-part-1-followup.html">original</a>)</p>
<p>Before I get started, I’ve changed the color scheme of this blog after a few comments about the previous colors I was using. Sorry for offending everyone’s eyes! Hopefully the current palette is easier to read.</p>
<p>Anyways, this is a quick followup to my previous post <a href="../posts/2015-12-26-haskell-game-server-part-1.html">Haskell Game Server - Part 1</a> which covers a few changes I made after some great feedback, and grievous debugging of a crazy issue.</p>
<h2 id="changes-to-server.hs">Changes to Server.hs</h2>
<p>The following things were pointed out to me:</p>
<ul>
<li>Use <code>forever</code> instead of recursive calls to the same function as it makes your intent clearer.</li>
<li><code>readMessage</code> should exist and be paired with <code>sendMessage</code> rather than wrapped up in the unrelated <code>runClient</code>.</li>
</ul>
<p>In a completely unrelated debugging nightmare that is oddly related to this specific code, I’ve also subtly changed how these methods work. With a high rate of messages flying back and forth we’d eventually lose a message here and there which was causing our event driven SDK to stall, even though it was clearly connected and doing other things. After scratching my head for a week I finally narrowed it down to two things today:</p>
<ul>
<li>Use <code>lockingInputStream</code> and <code>lockingOutputStream</code> if your sockets are accessed from other threads. This slows throughput down, but gives you thread-safety.</li>
<li>Rather than repeatedly call <code>socketToStreams</code> in each read/send function utilize memoization and store the socket pair in the <code>Client</code> record. This seemed to fix any lingering problems we had.</li>
</ul>
<p>The following is the revised code:</p>
<pre><code class="haskell">
runClient :: Server -> Client -> IO ()
runClient server client = forever $ do
  (mid, msg) <- readMessage (client^.clientInput)
  handleMessage server (client^.clientId) mid msg
  return ()

readMessage :: Streams.InputStream BS.ByteString -> IO (Word8, BS.ByteString)
readMessage in' = do
  inS <- Streams.lockingInputStream in'
  mid <- handleStream 1 inS
  lth <- handleStream 2 inS
  out <- if msgSize lth <= maxMsgSize
         then handleStream (msgSize lth) inS
         else return BS.empty
  return (midData mid, out)
  where
    midData mid' = fromIntegral $ runGet getWord8 (BL.fromStrict mid')
    msgSize lth' = (fromIntegral $ runGet getWord16be (BL.fromStrict lth')) :: Int
    handleStream len str =
      handle (\(SomeException e) -> do debug $ "read failed: " ++ show e; return BS.empty) $
        Streams.readExactly len str

sendMessage :: (GameMessage m, Encode m) => m -> Streams.OutputStream BS.ByteString -> IO ()
sendMessage msg out' = do
  outS <- Streams.lockingOutputStream out'
  handle (\(SomeException e) -> debug $ "write failed: " ++ show e ) $
    Streams.write (Just $ messageOutWithIdAndLength msg) outS
</code></pre>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script src="../js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-28958813-1']);
            _gaq.push(['_trackPageview']);
            (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
      </script>
    </body>
</html>
